%YAML 1.1
---
# CPAC Pipeline Configuration YAML file
# Version 1.8.5.dev
#
# http://fcp-indi.github.io for more info.
#
# Tip: This file can be edited manually with a text editor for quick modifications.
FROM: blank

pipeline_setup:

  # Name for this pipeline configuration - useful for identification.
  # This string will be sanitized and used in filepaths
  pipeline_name: cpac_abcd-options
  output_directory:

    # Quality control outputs
    quality_control:

      # Generate quality control pages containing preprocessing and derivative outputs.
      generate_quality_control_images: Off

      # Generate eXtensible Connectivity Pipeline-style quality control files
      generate_xcpqc_files: Off

  system_config:

    # The maximum amount of memory each participant's workflow can allocate.
    # Use this to place an upper bound of memory usage.
    # - Warning: 'Memory Per Participant' multiplied by 'Number of Participants to Run Simultaneously'
    #   must not be more than the total amount of RAM.
    # - Conversely, using too little RAM can impede the speed of a pipeline run.
    # - It is recommended that you set this to a value that when multiplied by
    #   'Number of Participants to Run Simultaneously' is as much RAM you can safely allocate.
    maximum_memory_per_participant: 10.0

    # Random seed used to fix the state of execution.
    # If unset, each process uses its own default.
    # If set, a `random.log` file will be generated logging the random seed and each node to which that seed was applied.
    # If set to a positive integer (up to 2147483647), that integer will be used to seed each process that accepts a random seed.
    # If set to 'random', a random positive integer (up to 2147483647) will be generated and that seed will be used to seed each process that accepts a random seed.
    random_seed:

    # Prior to running a pipeline C-PAC makes a rough estimate of a worst-case-scenario maximum concurrent memory usage with high-resoltion data, raising an exception describing the recommended minimum memory allocation for the given configuration.
    # Turning this option off will allow pipelines to run without allocating the recommended minimum, allowing for more efficient runs at the risk of out-of-memory crashes (use at your own risk)
    raise_insufficient: On

    # A callback.log file from a previous run can be provided to estimate memory usage based on that run.
    observed_usage:

      # Path to callback log file with previously observed usage.
      # Can be overridden with the commandline flag `--runtime_usage`.
      callback_log:

      # Percent. E.g., `buffer: 10` would estimate 1.1 * the observed memory usage from the callback log provided in "usage".
      # Can be overridden with the commandline flag `--runtime_buffer`.
      buffer: 10

# PREPROCESSING
# -------------
surface_analysis:

  # Will run Freesurfer for surface-based analysis. Will output traditional Freesurfer derivatives.
  # If you wish to employ Freesurfer outputs for brain masking or tissue segmentation in the voxel-based pipeline,
  # select those 'Freesurfer-' labeled options further below in anatomical_preproc.
  freesurfer:

    # Add extra arguments to recon-all command
    reconall_args:

    # (Optional) Provide an already-existing FreeSurfer output directory to ingress already-computed surfaces
    freesurfer_dir:

    # If anatomical_preproc['brain_extraction']['using'] includes FreeSurfer-ABCD and this switch is On, C-PAC will automatically turn this switch Off to avoid running FreeSurfer twice unnecessarily
    # FreeSurfer will run as part of configured brain extraction in this specific configuration, so FreeSurfer's independent run was automatically disabled.
    run: Off

  # Run ABCD-HCP post FreeSurfer and fMRISurface pipeline
  post_freesurfer:
    run: On
    subcortical_gray_labels: /opt/dcan-tools/pipeline/global/config/FreeSurferSubcorticalLabelTableLut.txt
    freesurfer_labels: /opt/dcan-tools/pipeline/global/config/FreeSurferAllLut.txt
    surf_atlas_dir: /opt/dcan-tools/pipeline/global/templates/standard_mesh_atlases
    gray_ordinates_dir: /opt/dcan-tools/pipeline/global/templates/Greyordinates
    gray_ordinates_res: 2
    high_res_mesh: 164
    low_res_mesh: 32
    fmri_res: 2
    smooth_fwhm: 2

anatomical_preproc:
  run: On

  # Non-local means filtering via ANTs DenoiseImage
  non_local_means_filtering:

    # this is a fork option
    run: [On]

    # options: 'Gaussian' or 'Rician'
    noise_model: Rician

  # N4 bias field correction via ANTs
  n4_bias_field_correction:

    # this is a fork option
    run: [On]

    # An integer to resample the input image to save computation time. Shrink factors <= 4 are commonly used.
    shrink_factor: 4

  acpc_alignment:
    run: On

    # Run ACPC alignment before non-local means filtering or N4 bias
    # correction
    run_before_preproc: Off

    # ACPC aligned template
    T1w_ACPC_template: /opt/dcan-tools/pipeline/global/templates/MNI152_T1_1mm.nii.gz
    T1w_brain_ACPC_template: $FSLDIR/data/standard/MNI152_T1_1mm_brain.nii.gz

    # Choose a tool to crop the FOV in ACPC alignment.
    # Using FSL's robustfov or flirt command.
    # Default: robustfov for human data, flirt for monkey data.
    FOV_crop: robustfov

    # Run ACPC alignment on brain mask
    # If the brain mask is in native space, turn it on
    # If the brain mask is ACPC aligned, turn it off
    align_brain_mask: Off
    T2w_ACPC_template:
    T2w_brain_ACPC_template:

  brain_extraction:

    # using: ['3dSkullStrip', 'BET', 'UNet', 'niworkflows-ants', 'FreeSurfer-ABCD', 'FreeSurfer-BET-Tight', 'FreeSurfer-BET-Loose']
    # this is a fork option
    using: [FreeSurfer-ABCD]
    run: On
    FreeSurfer-BET:

      # Template to be used for FreeSurfer-BET brain extraction in CCS-options pipeline
      T1w_brain_template_mask_ccs: /ccs_template/MNI152_T1_1mm_first_brain_mask.nii.gz

  run_t2: Off

  # Bias field correction based on square root of T1w * T2w
  t1t2_bias_field_correction:
    run: Off
    BiasFieldSmoothingSigma: 5

segmentation:

  # Automatically segment anatomical images into white matter, gray matter,
  # and CSF based on prior probability maps.
  run: On

registration_workflows:
  anatomical_registration:
    run: On

    # The resolution to which anatomical images should be transformed during registration.
    # This is the resolution at which processed anatomical files will be output.
    resolution_for_anat: 1mm

    # Template to be used during registration.
    # It is not necessary to change this path unless you intend to use a non-standard template.
    T1w_brain_template: /opt/dcan-tools/pipeline/global/templates/MNI152_T1_${resolution_for_anat}_brain.nii.gz

    # Template to be used during registration.
    # It is not necessary to change this path unless you intend to use a non-standard template.
    T1w_brain_template_mask: /opt/dcan-tools/pipeline/global/templates/MNI152_T1_${resolution_for_anat}_brain_mask.nii.gz
    registration:

      # option parameters
      ANTs:

        # ANTs parameters for T1-template-based registration
        T1_registration:
          - verbose: On
          - float: Off
          - collapse-output-transforms: 0
          - dimensionality: 3
          - winsorize-image-intensities:
              lowerQuantile: 0.005
              upperQuantile: 0.995
          - initial-moving-transform:
              initializationFeature: 1
          - transforms:
            - Rigid:
                convergence:
                  convergenceThreshold: 1e-6
                  convergenceWindowSize: 10
                  iteration: 1000x500x250x100
                gradientStep: 0.1
                masks: Off
                metric:
                  metricWeight: 1
                  numberOfBins: 32
                  samplingPercentage: 0.25
                  samplingStrategy: Regular
                  type: MI
                shrink-factors: 8x4x2x1
                smoothing-sigmas: 3.0x2.0x1.0x0.0
                use-histogram-matching: Off
            - Affine:
                convergence:
                  convergenceThreshold: 1e-6
                  convergenceWindowSize: 10
                  iteration: 1000x500x250x100
                gradientStep: 0.1
                masks: Off
                metric:
                  metricWeight: 1
                  numberOfBins: 32
                  samplingPercentage: 0.25
                  samplingStrategy: Regular
                  type: MI
                shrink-factors: 8x4x2x1
                smoothing-sigmas: 3.0x2.0x1.0x0.0
                use-histogram-matching: Off
            - SyN:
                convergence:
                  convergenceThreshold: 1e-6
                  convergenceWindowSize: 10
                  iteration: 100x70x50x20
                gradientStep: 0.1
                masks: On
                metric:
                  metricWeight: 1
                  radius: 4
                  type: CC
                shrink-factors: 8x4x2x1
                smoothing-sigmas: 3.0x2.0x1.0x0.0
                totalFieldVarianceInVoxelSpace: 0.0
                updateFieldVarianceInVoxelSpace: 3.0
                use-histogram-matching: Off

        # Interpolation method for writing out transformed anatomical images.
        # Possible values: Linear, BSpline, LanczosWindowedSinc
        interpolation: Linear

      FSL-FNIRT:

        # The resolution to which anatomical images should be transformed during registration.
        # This is the resolution at which processed anatomical files will be output.
        # specifically for monkey pipeline
        ref_resolution: 2mm

        # Template to be used during registration.
        # It is for monkey pipeline specifically.
        FNIRT_T1w_brain_template:

        # Template to be used during registration.
        # It is for monkey pipeline specifically.
        FNIRT_T1w_template:

        # Reference mask with 2mm resolution to be used during FNIRT-based brain extraction in ABCD-options pipeline.
        ref_mask_res-2: /opt/dcan-tools/pipeline/global/templates/MNI152_T1_2mm_brain_mask_dil.nii.gz

        # Template with 2mm resolution to be used during FNIRT-based brain extraction in ABCD-options pipeline.
        T1w_template_res-2: /opt/dcan-tools/pipeline/global/templates/MNI152_T1_2mm.nii.gz

    overwrite_transform:
      run: On

      # Choose the tool to overwrite transform, currently only support 'FSL' to overwrite 'ANTs' transforms in ABCD-options pipeline.
      # using: 'FSL'
      using: FSL

  functional_registration:
    coregistration:

      # functional (BOLD/EPI) registration to anatomical (structural/T1)
      run: On
      func_input_prep:

        # Choose whether to use the mean of the functional/EPI as the input to functional-to-anatomical registration or one of the volumes from the functional 4D timeseries that you choose.
        # input: ['Mean_Functional', 'Selected_Functional_Volume', 'fmriprep_reference']
        input: [Selected_Functional_Volume]

        # Choose whether to use functional brain or skull as the input to functional-to-anatomical registration
        reg_with_skull: On

      boundary_based_registration:

        # reference for boundary based registration
        # options: 'whole-head' or 'brain'
        reference: whole-head

        # choose which FAST map to generate BBR WM mask
        # options: 'probability_map', 'partial_volume_map'
        bbr_wm_map: probability_map

        # optional FAST arguments to generate BBR WM mask
        bbr_wm_mask_args: -thr 0.5 -bin

      # reference: 'brain' or 'restore-brain'
      # In ABCD-options pipeline, 'restore-brain' is used as coregistration reference
      reference: restore-brain

      # Choose FSL or ABCD as coregistration method
      using: FSL

      # Choose brain or whole-head as coregistration input
      input: brain

      # Choose coregistration interpolation
      interpolation: spline

      # Choose coregistration cost function
      cost: corratio

      # Choose coregistration degree of freedom
      dof: 12

      # Extra arguments for FSL flirt
      arguments:

    func_registration_to_template:

      # these options modify the application (to the functional data), not the calculation, of the
      # T1-to-template and EPI-to-template transforms calculated earlier during registration
      # apply the functional-to-template (T1 template) registration transform to the functional data
      run: On
      output_resolution:

        # The resolution (in mm) to which the preprocessed, registered functional timeseries outputs are written into.
        # NOTE:
        #   selecting a 1 mm or 2 mm resolution might substantially increase your RAM needs- these resolutions should be selected with caution.
        #   for most cases, 3 mm or 4 mm resolutions are suggested.
        # NOTE:
        #   this also includes the single-volume 3D preprocessed functional data,
        #   such as the mean functional (mean EPI) in template space
        func_preproc_outputs: 2mm

        # The resolution (in mm) to which the registered derivative outputs are written into.
        # NOTE:
        #   this is for the single-volume functional-space outputs (i.e. derivatives)
        #   thus, a higher resolution may not result in a large increase in RAM needs as above
        func_derivative_outputs: 2mm

      target_template:
        T1_template:

          # Standard Skull Stripped Template. Used as a reference image for functional registration.
          # This can be different than the template used as the reference/fixed for T1-to-template registration.
          T1w_brain_template_funcreg: /opt/dcan-tools/pipeline/global/templates/MNI152_T1_${func_resolution}_brain.nii.gz

          # Standard Anatomical Brain Image with Skull.
          # This can be different than the template used as the reference/fixed for T1-to-template registration.
          T1w_template_funcreg: /opt/dcan-tools/pipeline/global/templates/MNI152_T1_${func_resolution}.nii.gz

          # Template to be used during registration.
          # It is not necessary to change this path unless you intend to use a non-standard template.
          T1w_brain_template_mask_funcreg: /opt/dcan-tools/pipeline/global/templates/MNI152_T1_${func_resolution}_brain_mask.nii.gz

      ANTs_pipelines:

        # Interpolation method for writing out transformed functional images.
        # Possible values: Linear, BSpline, LanczosWindowedSinc
        interpolation: Linear

      # apply the functional-to-template (EPI template) registration transform to the functional data
      run_EPI: Off
      apply_transform:

        # options: 'default', 'abcd', 'single_step_resampling_from_stc', 'dcan_nhp'
        # 'default': apply func-to-anat and anat-to-template transforms on motion corrected functional image.
        # 'abcd': apply motion correction, func-to-anat and anat-to-template transforms on each of raw functional volume using FSL applywarp based on ABCD-HCP pipeline.
        # 'single_step_resampling_from_stc': apply motion correction, func-to-anat and anat-to-template transforms on each of slice-time-corrected functional volume using ANTs antsApplyTransform based on fMRIPrep pipeline.
        #   - if 'single_step_resampling_from_stc', 'template' is the only valid option for ``nuisance_corrections: 2-nuisance_regression: space``
        using: abcd

functional_preproc:
  run: On
  slice_timing_correction:

    # use specified slice time pattern rather than one in header
    tpattern:

    # align each slice to given time offset
    # The default alignment time is the average of the 'tpattern' values (either from the dataset header or from the tpattern option).
    tzero:

  motion_estimates_and_correction:
    motion_estimates:

      # calculate motion statistics BEFORE slice-timing correction
      calculate_motion_first: On

      # calculate motion statistics AFTER motion correction
      calculate_motion_after: Off

    motion_correction:

      # using: ['3dvolreg', 'mcflirt']
      # this is a fork point
      using: [mcflirt]

      # Choose motion correction reference. Options: mean, median, selected_volume, fmriprep_reference
      motion_correction_reference: [selected_volume]

    run: On

  distortion_correction:

    # this is a fork point
    #   run: [On, Off] - this will run both and fork the pipeline
    run: [On]

    # using: ['PhaseDiff', 'Blip', 'Blip-FSL-TOPUP']
    #   PhaseDiff - Perform field map correction using a single phase difference image, a subtraction of the two phase images from each echo. Default scanner for this method is SIEMENS.
    #   Blip - Uses AFNI 3dQWarp to calculate the distortion unwarp for EPI field maps of opposite/same phase encoding direction.
    #   Blip-FSL-TOPUP - Uses FSL TOPUP to calculate the distortion unwarp for EPI field maps of opposite/same phase encoding direction.
    using: [PhaseDiff, Blip-FSL-TOPUP]
    Blip-FSL-TOPUP:

      # (approximate) resolution (in mm) of warp basis for the different sub-sampling levels, default 10
      warpres: 10

      # sub-sampling scheme, default 1
      subsamp: 1

      # FWHM (in mm) of gaussian smoothing kernel, default 8
      fwhm: 8

      # Max # of non-linear iterations, default 5
      miter: 5

      # Weight of regularisation, default depending on --ssqlambda and --regmod switches. See user documentation.
      lambda: 1

      # If set (=1), lambda is weighted by current ssq, default 1
      ssqlambda: 1

      # Model for regularisation of warp-field [membrane_energy bending_energy], default bending_energy
      regmod: bending_energy

      # Estimate movements if set, default 1 (true)
      estmov: 1

      # Minimisation method 0=Levenberg-Marquardt, 1=Scaled Conjugate Gradient, default 0 (LM)
      minmet: 0

      # Order of spline, 2->Qadratic spline, 3->Cubic spline. Default=3
      splineorder: 3

      # Precision for representing Hessian, double or float. Default double
      numprec: double

      # Image interpolation model, linear or spline. Default spline
      interp: spline

      # If set (=1), the images are individually scaled to a common mean, default 0 (false)
      scale: 0

      # If set (=1), the calculations are done in a different grid, default 1 (true)
      regrid: 1

  func_masking:

    # using: ['AFNI', 'FSL', 'FSL_AFNI', 'Anatomical_Refined', 'Anatomical_Based', 'Anatomical_Resampled', 'CCS_Anatomical_Refined']
    # FSL_AFNI: fMRIPrep-style BOLD mask. Ref: https://github.com/nipreps/niworkflows/blob/a221f612/niworkflows/func/util.py#L246-L514
    # Anatomical_Refined: 1. binarize anat mask, in case it is not a binary mask. 2. fill holes of anat mask 3. init_bold_mask : input raw func → dilate init func brain mask 4. refined_bold_mask : input motion corrected func → dilate anatomical mask 5. get final func mask
    # Anatomical_Based: Generate the BOLD mask by basing it off of the anatomical brain mask. Adapted from DCAN Lab's BOLD mask method from the ABCD pipeline.
    # Anatomical_Resampled: Resample anatomical brain mask in standard space to get BOLD brain mask in standard space. Adapted from DCAN Lab's BOLD mask method from the ABCD pipeline. ("Create fMRI resolution standard space files for T1w image, wmparc, and brain mask […] don't use FLIRT to do spline interpolation with -applyisoxfm for the 2mm and 1mm cases because it doesn't know the peculiarities of the MNI template FOVs")
    # CCS_Anatomical_Refined: Generate the BOLD mask by basing it off of the anatomical brain. Adapted from the BOLD mask method from the CCS pipeline.
    # this is a fork point
    using: [Anatomical_Resampled]
    FSL-BET:

      # Set an intensity threshold to improve skull stripping performances of FSL BET on rodent scans.
      functional_mean_thr:
        run: Off
        threshold_value: 98

      # Bias correct the functional mean image to improve skull stripping performances of FSL BET on rodent scans
      functional_mean_bias_correction: Off

    FSL_AFNI:
      bold_ref:
      brain_mask: $FSLDIR/data/standard/MNI152_T1_${resolution_for_anat}_brain_mask.nii.gz
      brain_probseg: $FSLDIR/data/standard/MNI152_T1_${resolution_for_anat}_brain_mask.nii.gz

    # Apply functional mask in native space
    apply_func_mask_in_native_space: Off

  generate_func_mean:

    # Generate mean functional image
    run: On

  normalize_func:

    # Normalize functional image
    run: Off

nuisance_corrections:
  2-nuisance_regression:

    # Select which nuisance signal corrections to apply
    Regressors:
      - Name: default
        Bandpass:
          bottom_frequency: 0.01
          method: default
          top_frequency: 0.1
        Motion:
          include_delayed: On
          include_delayed_squared: On
          include_squared: On

    # Process and refine masks used to produce regressors and time series for
    # regression.
    regressor_masks:
      erode_anatomical_brain_mask:

        # Erode brain mask in millimeters, default for brain mask is 30 mm
        # Brain erosion default is using millimeters.
        brain_mask_erosion_mm: 30

      erode_csf:

        # Erode cerebrospinal fluid mask in millimeters, default for cerebrospinal fluid is 30mm
        # Cerebrospinal fluid erosion default is using millimeters.
        csf_mask_erosion_mm: 30

      erode_wm:

        # Target volume ratio, if using erosion.
        # Default proportion is 0.6 for white matter mask.
        # If using erosion, using both proportion and millimeters is not recommended.
        # White matter erosion default is using proportion erosion method when use erosion for white matter.
        wm_erosion_prop: 0.6

      erode_gm:

        # Target volume ratio, if using erosion.
        # If using erosion, using both proportion and millimeters is not recommended.
        gm_erosion_prop: 0.6

    # this is a fork point
    # Run nuisance regression in native or template space
    #   - If set to [native, template], the number of outputs will be double what it would be if only one space were chosen. Nuisance regression will only be run once per fork.
    #   - If set to template, will use the brain mask configured in
    #     ``functional_preproc: func_masking: FSL_AFNI: brain_mask``
    #   - If ``registration_workflows: functional_registration: func_registration_to_template: apply_trasnform: using: single_step_resampling_from_stc``, this must only be set to template
    space: [native]

    # switch to Off if nuisance regression is off and you don't want to write out the regressors
    create_regressors: Off

timeseries_extraction:
  connectivity_matrix:

    # Create a connectivity matrix from timeseries data
    # Options:
    #  ['AFNI', 'Nilearn', 'ndmg']
    using: [Nilearn, ndmg]

    # Options:
    #  ['Pearson', 'Partial']
    # Note: These options are not configurable for ndmg, which will ignore these options
    measure: [Pearson, Partial]

seed_based_correlation_analysis:

  # Enter paths to region-of-interest (ROI) NIFTI files (.nii or .nii.gz) to be used for seed-based correlation analysis, and then select which types of analyses to run.
  # Denote which analyses to run for each ROI path by listing the names below. For example, if you wish to run Avg and MultReg, you would enter: '/path/to/ROI.nii.gz': Avg, MultReg
  # available analyses:
  #   /path/to/atlas.nii.gz: Avg, DualReg, MultReg
  sca_roi_paths:
    /cpac_templates/CC400.nii.gz: Avg
