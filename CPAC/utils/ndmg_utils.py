
# Functions in this file adapted from NeuroData group:

# Copyright 2016 NeuroData (http://neurodata.io)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# graph.py
# Created by Greg Kiar on 2016-01-27.
# Email: gkiar@jhu.edu

# Can be found here:
#   https://github.com/neurodata/ndmg/blob/merge-dmri-fmri/

import os
import nibabel as nb
import numpy as np


def ndmg_roi_timeseries(func_file, label_file):
    """
    Function to extract average timeseries for the voxels in each
    roi of the labelled atlas.
    Returns the roi timeseries as a numpy.ndarray.
    **Positional Arguments**
        func_file:
            - the path to the 4d volume to extract timeseries
        label_file:
            - the path to the labelled atlas containing labels
                for the voxels in the fmri image
        roits_file:
            - the path to where the roi timeseries will be saved. If
            None, don't save and just return the roi_timeseries.

    # Adapted from ndmg v0.1.1
    # Copyright 2016 NeuroData (http://neurodata.io)
    """
    labeldata = nb.load(label_file).get_data()
    # rois are all the nonzero unique values the parcellation can take
    rois = np.sort(np.unique(labeldata[labeldata > 0]))
    funcdata = nb.load(func_file).get_data()

    # initialize time series to [numrois]x[numtimepoints]
    roi_ts = np.zeros((len(rois), funcdata.shape[3]))
    # iterate over the unique possible rois. note that the rois
    # could have nonstandard values, so assign indices w enumerate
    for idx, roi in enumerate(rois):
        roibool = labeldata == roi  # get a bool where our voxels in roi
        try:
            roi_vts = funcdata[roibool, :]
        except IndexError as e:
            err = '\n[!] Error: functional data and ROI mask may not be in ' \
                  'the same space or be the same size.\nDetails: ' \
                  '{0}'.format(e)
            raise IndexError(err)
        # take the mean for the voxel timeseries, and ignore voxels with
        # no variance
        ts = roi_vts[roi_vts.std(axis=1) != 0, :].mean(axis=0)
        if ts.size != 0:
            roi_ts[idx, :] = ts

    roits_file = os.path.join(os.getcwd(), 'timeseries.npz')
    np.savez(roits_file, ts=roi_ts, rois=rois)
    return (roi_ts, rois, roits_file)


class graph(object):
    def __init__(self, N, rois, attr=None, sens="dwi"):
        """
        Initializes the graph with nodes corresponding to the number of ROIs
        **Positional Arguments:**
                N:
                    - Number of rois
                rois:
                    - Set of ROIs as either an array or niftii file)
                attr:
                    - Node or graph attributes. Can be a list. If 1 dimensional
                      will be interpretted as a graph attribute. If N
                      dimensional will be interpretted as node attributes. If
                      it is any other dimensional, it will be ignored.

        # Adapted from ndmg v0.1.1
        # Copyright 2016 NeuroData (http://neurodata.io)
        """
        import numpy as np
        import nibabel as nb
        from collections import defaultdict
        self.N = N
        self.edge_dict = defaultdict(int)

        self.rois = nb.load(rois).get_data()
        n_ids = np.unique(self.rois)
        self.n_ids = n_ids[n_ids > 0]

        self.modal = sens
        pass

    def make_graph(self, streamlines, attr=None):
        """
        Takes streamlines and produces a graph
        **Positional Arguments:**
                streamlines:
                    - Fiber streamlines either file or array in a dipy EuDX
                      or compatible format.
        """
        import time
        import numpy as np
        import networkx as nx
        from itertools import product

        self.g = nx.Graph(name="Generated by NeuroData's MRI Graphs (ndmg)",
                          version='0.1.1',
                          date=time.asctime(time.localtime()),
                          source="http://m2g.io",
                          region="brain",
                          sensor=self.modal,
                          ecount=0,
                          vcount=len(self.n_ids)
                          )
        print(self.g.graph)
        [str(self.g.add_node(ids)) for ids in self.n_ids]

        nlines = np.shape(streamlines)[0]
        print("# of Streamlines: " + str(nlines))
        print_id = np.max((int(nlines*0.05), 1))  # in case nlines*.05=0
        for idx, streamline in enumerate(streamlines):
            if (idx % print_id) == 0:
                print(idx)

            points = np.round(streamline).astype(int)
            p = set()
            for point in points:
                try:
                    loc = self.rois[point[0], point[1], point[2]]
                except IndexError:
                    pass
                else:
                    pass

                if loc:
                    p.add(loc)
            edges = set([tuple(sorted(x)) for x in product(p, p)])
            for edge in edges:
                lst = tuple(sorted([str(node) for node in edge]))
                self.edge_dict[lst] += 1
        edge_list = [(int(k[0]), int(k[1]), v) for k, v in self.edge_dict.items()]
        self.g.add_weighted_edges_from(edge_list)

    def cor_graph(self, timeseries, attr=None):
        """
        Takes timeseries and produces a correlation matrix
        **Positional Arguments:**
            timeseries:
                -the timeseries file to extract correlation for.
                          dimensions are [numrois]x[numtimesteps]
        """
        import numpy as np
        ts = timeseries[0]
        rois = timeseries[1]
        print("Estimating correlation matrix for {} ROIs...".format(self.N))
        self.g = np.abs(np.corrcoef(timeseries))  # calculate pearson correlation
        self.g = np.nan_to_num(self.g).astype(object)
        self.n_ids = rois
        # roilist = self.g.nodes()

        # for (idx_out, roi_out) in enumerate(roilist):
        #     for (idx_in, roi_in) in enumerate(roilist):
        #         self.edge_dict[(roi_out, roi_in)] = float(cor[idx_out, idx_in])

        # edge_list = [(str(k[0]), str(k[1]), v) for k, v in self.edge_dict.items()]
        # self.g.add_weighted_edges_from(edge_list)
        return self.g

    def get_graph(self):
        """
        Returns the graph object created
        """
        try:
            return self.g
        except AttributeError:
            print("Error: the graph has not yet been defined.")
            pass

    def as_matrix(self):
        """
        Returns the graph as a matrix.
        """
        import networkx as nx
        g = self.get_graph()
        return nx.to_numpy_matrix(g, nodelist=np.sort(g.nodes()).tolist())

    def save_graph(self, graphname):
        """
        Saves the graph to disk
        **Positional Arguments:**
                graphname:
                    - Filename for the graph
        """
        import numpy as np
        import networkx as nx
        if self.modal == 'dwi':
            self.g.graph['ecount'] = nx.number_of_edges(self.g)
            nx.write_weighted_edgelist(self.g, graphname, delimiter=",")

        elif self.modal == 'func':
            np.savetxt(graphname, self.g, comments='', delimiter=',',
                header=','.join([str(n) for n in self.n_ids]))
        else:
            raise ValueError("Unsupported Modality.")
        pass

    def summary(self):
        """
        User friendly wrapping and display of graph properties
        """
        import networkx as nx
        print("\n Graph Summary:")
        print(nx.info(self.g))
        pass


def ndmg_create_graphs(ts, labels):
    out_file = os.path.join(os.getcwd(), 'measure-correlation.csv')
    connectome = graph(ts.shape[0], labels, sens="func")
    conn = connectome.cor_graph(ts)
    connectome.save_graph(out_file)
    return out_file
